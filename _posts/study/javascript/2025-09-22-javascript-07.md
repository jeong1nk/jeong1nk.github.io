---
layout: single
title: "[javascript] 07장_연산자"
categories: javascript
tag: [study, javascript, frontend, ModernJavaScriptDeepDive]
toc: true
excerpt: "ModernJavaScriptDeepDive 도서의 07장_연산자 정리"
---

- **🏷️연산자(operator): 하나 이상의 표현식을 대상, 산술, 할당, 비교, 논리, 타입, 지수, 연산 등을 수행해 하나의 값을 만듦**
- **🏷️피연산자: 연산의 대상, 값으로 평가될 수 있는 표현식**
<br />

- 피연산자는 연산의 대상이 되어야 하므로 값으로 평가할 수 있어야 하며, 연산자는 값으로 평가된 피연산자를 연산해 새로운 값을 만든다.

# 7.1. 산술 연산자
- **🏷️산술 연산자: 수학적 계산을 수행해 새로운 숫자 값을 만든다.**
- 산술 연산이 불가능한 경우 `NaN`을 반환한다.
- 피연산자의 개수에 따라 **이항 산술 연산자**와 **단항 산술 연산자**로 구분한다.

## 7.1.1. 이항 산술 연산자 
- **🏷️이항 산술 연산자: 2개의 피연산자를 산술 연산하여 숫자 값을 만든다.**
- `+(덧셈)`, `-(뺄셈)`, `*(곱셈)`, `/(나눗셈)`, `%(나머지)`
- 피연산자의 **값을 변경하지 않고 언제나 새로운 값을 만든다.**

## 7.1.2. 단항 산술 연산자 
- **🏷️단항 산술 연산자: 1개의 피연산자를 산술 연산하여 숫자 값을 만든다.**
- `++(증가)`, `--(감소)`, `+(어떠한 효과도 없음)`, `-(피연산자의 부호를 반전한 값을 반환)`
<br />

- **`++`, `--`는 피연산자의 값을 변경하는 부수 효과가 있으며, 위치에 의미가 있다.**
- 피연산자의 **앞**에 위치: `전위 증가/감소 연산자`로 불리며, **먼저 피연산자의 값을 증가/감소 시킨 후, 다른 연산을 수행한다.**
- 피연산자의 **뒤**에 위치: `후위 증가/감소 연산자`로 불리며, **먼저 다른 연산을 수행한 후, 피연산자의 값을 증가/감소 시킨다.**
<br />

- `+`: **숫자 타입이 아닌 피연산자에 사용할 경우, 피연산자를 숫자 타입으로 변환하여 반환**한다.

```javascript
var x  = '1';

// 문자열을 숫자로 타입 변환한다.
console.log(+x); // 1
// 부수 효과는 없다.
console.log(x);  // "1"

// 불리언 값을 숫자로 타입 변환한다.
x = true;
console.log(+x); // 1
// 부수 효과는 없다.
console.log(x);  // true

// 불리언 값을 숫자로 타입 변환한다.
x = false;
console.log(+x); // 0
// 부수 효과는 없다.
console.log(x);  // false

// 문자열을 숫자로 타입 변환할 수 없으므로 NaN을 반환한다.
x = 'Hello';
console.log(+x); // NaN
// 부수 효과는 없다.
console.log(x);  // "Hello"
```
<br />

- `-`: **양수는 음수로, 음수는 양수로 반전한 값 반환**한다. 또, **숫자 타입이 아닌 피연산자에 사용할 경우, 피연산자를 숫자 타입으로 변환하여 반환**한다.

```javascript
// 부호를 반전한다.
-(-10); // -> 10

// 문자열을 숫자로 타입 변환한다.
-'10'; // -> -10

// 불리언 값을 숫자로 타입 변환한다.
-true; // -> -1

// 문자열은 숫자로 타입 변환할 수 없으므로 NaN을 반환한다.
-'Hello'; // -> NaN
```

## 7.1.3. 문자열 연결 연산자
- **`+`: 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다.**

```javascript
// 문자열 연결 연산자
'1' + 2; // -> '12'
1 + '2'; // -> '12'

// 산술 연산자
1 + 2; // -> 3

// true는 1로 타입 변환된다.
1 + true; // -> 2

// false는 0으로 타입 변환된다.
1 + false; // -> 1

// null은 0으로 타입 변환된다.
1 + null; // -> 1

// undefined는 숫자로 타입 변환되지 않는다.
+undefined;    // -> NaN
1 + undefined; // -> NaN
```

- 위의 1+true=2와 같이 true가 1로 암묵적으로 타입이 변환되는 경우가 있다. 이를 `암묵적 타입 변환` 또는 `타입 강제 변환`이라고 한다.

# 7.2. 할당 연산자
- 🏷️**할당 연산자: 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당**
- `=`, `+=`, `-=`, `*=`, `/=`, `%=`
- **할당문은 값으로 평가되는 표현식인 문으로서 할당된 값으로 평가된다.**

# 7.3. 비교 연산자
- 🏷️**비교 연산자 : 좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값으로 반환** 

## 7.3.1. 동등/일치 비교 연산자
- **🏷️동등/일치 비교 연산자: 좌항과 우항의 피연산자가 같은 값으로 평가되는지 비교해 불리언 값으로 반환한다.**
- **동등 비교 연산자는 느슨한 비교**를, **일치 비교 연산자는 엄격한 비교**를 한다.
- 동등 비교 연산자: `==`(값이 같은지), `===`(타입이 같은지)
- 일치 비교 연산자: `!=`(값이 다른지), `!==`(타입이 다른지)
<br />

- 🏷️동등 비교 연산자: **암묵적 타입변환을 통해 타입을 일치시킨 후 같은 값인지 비교한다.** 그러므로 타입이 달라도 **암묵적 타입 변환 후에 같은 값일 수 있다면 true를 반환**

```javascript
// 동등 비교
5 == 5; // -> true

// 타입은 다르지만 암묵적 타입 변환을 통해 타입을 일치시키면 동등하다.
5 == '5'; // -> true
```

- 🏷️일치 비교 연산자: 타입과 값 모두 같은 경우에 한하여 true를 반환 **즉, 암묵적 타입 변환을 하지 않고 값을 비교**
- 그러므로 동등 비교 연산자 보다는 일치 비교 연산자를 사용하는 것이 좋다. 하지만 NaN과 숫자 0을 주의하자.
- NaN은 **자신과 일치하지 않는 유일한 값**으로, **숫자가 NaN인지 조사하려면 빌트인 함수 `Number.isNaN`을 사용한다.**

```javascript
// NaN은 자신과 일치하지 않는 유일한 값이다.
NaN === NaN; // -> false

// Number.isNaN 함수는 지정한 값이 NaN인지 확인하고 그 결과를 불리언 값으로 반환한다.
Number.isNaN(NaN); // -> true
Number.isNaN(10);  // -> false
Number.isNaN(1 + undefined); // -> true
```

- 자바스크립트에는 0에도 양과 음이 있으며, 이들을 비교하면 true를 반환하므로 주의하자.

```javascript
// 양의 0과 음의 0의 비교. 일치 비교/동등 비교 모두 결과는 true이다.
0 === -0; // -> true
0 == -0;  // -> true
```

## 7.3.2. 대소 관계 비교연산자
- 🏷️대소 관계 비교연산자: 피연산자의 크기를 비교하여 불리언 값을 반환
- `>`, `<`, `>=`, `<=`

# 7.4. 삼항 조건 연산자
- **🏷️삼항 조건 연산자: 조건식의 평가 결과에 따라 반환할 값을 결정**

```javascript
조건식 ? 조건식이 true일 때 반환할 값 : 조건식이 false일 때 반환할 값
```

- 삼항 조건 연산자 표현식은 **값으로 평가할 수 있는 표현식인 문**이다. 따라서 **값처럼 다른 표현식의 일부가 될 수 있어 매우 유용**하다. 

# 7.5. 논리 연산자
- **🏷️논리 연산자: 우항과 좌항의 피연산자(부정 논리의 경우 우항)를 논리 연산**
- `||`(논리합(OR)), `&&`(논리곱(AND)), `!`(부정(NOT))
- 논리 부정 연산자(`!`)는 언제나 불리언값을 반환한다. 피연산자가 불리언 값이 아닐 경우 암묵적 타입 변환한다.

```javascript
// 암묵적 타입 변환
!0;       // -> true
!'Hello'; // -> false
```

- 또,  논리합(`||`), 논리곱(`&&`) 연산자의 결과값은 불리언이 아닐 수도 있다. 논리합과 논리곱 연산자는 어느 한쪽으로 평가 된다.

```javascript
// 단축 평가
'Cat' && 'Dog'; // -> 'Dog'
```

# 7.6. 쉼표 연산자
- **🏷️쉼표 연산자: 왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연사자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환**

```javascript
var x, y, z;

x = 1, y = 2, z = 3; // 3
```

# 7.7. 그룹 연산자
- **🏷️그룹 연산자(`()`): 자신의 피연산자인 표현식을 가장 먼저 평가**
- **★연산자 우선순위가 가장 높다.★**

# 7.8. typeof 연산자
- **🏷️typeof 연산자: 피연산자의 데이터 타입을 문자열로 반환한다.**
- `string`, `number`, `boolean`, `undefined`, `symbol`, `object`, `function` 중 하나를 반환한다.

```javascript
typeof ''              // -> "string"
typeof 1               // -> "number"
typeof NaN             // -> "number"
typeof true            // -> "boolean"
typeof undefined       // -> "undefined"
typeof Symbol()        // -> "symbol"
typeof null            // -> "object"
typeof []              // -> "object"
typeof {}              // -> "object"
typeof new Date()      // -> "object"
typeof /test/gi        // -> "object"
typeof function () {}  // -> "function"
```

- **null에 typeof 연산자를 사용할 시 `object`를 반환하는 것에 주의**. 자바스크립트의 버그이지만, 기존 코드에 영향을 줄 수 있어 수정되지 않고 있다.
- 그러므로 값이 'null'인지 확인할 때는 `일치 연산자(===)`를 사용하자.

```javascript
var foo = null;

typeof foo === null; // -> false
foo === null;        // -> true
```

- 또, 선언하지 않은 식별자를 `typeof`로 연산하면 `undefiend`를 반환하는 것도 주의.

```javascript
// undeclared 식별자를 선언한 적이 없다.
typeof undeclared; // -> undefined
```

# 7.9. 지수 연산자
- **🏷️지수 연산자: 좌항의 피연산자를 밑(base)으로, 우항의 피연산자를 지수(exponent)로 거듭 제곱하여 숫자 값을 반환한다.**

```javascript
2 ** 2;   // -> 4
2 ** 2.5; // -> 5.65685424949238
2 ** 0;   // -> 1
2 ** -2;  // -> 0.25
```

- 다른 산술 연산자와 마찬가지로 할당 연산자와 함께 사용할 수 있으며, **지수 연산자는 이항 연산자 중에서 우선순위가 가장 높다.**

```javascript
var num = 5;
num **= 2; // -> 25

2 * 5 ** 2; // -> 50
```

# 7.10. 그 외의 연산자
- 그 외에도 다양한 연산자가 있지만, 별도의 장에서 소개예정
- `?.`(옵셔널 체이닝 연산자), `??`(null 병합연산자), `delete`(프로퍼티 삭제), `new`(생성자 함수를 호출할때 사용해 인스턴스를 생성), `instanceof`(좌변의 객체가 우변의 생성자 함수와 연결된 인스턴스인지 판별), `in`(프로퍼티 존재 확인)

# 7.11. 연산자의 부수 효과
- 다른 코드에 영향을 주는 부수효과를 가진 연산자는 `할당 연산자(=)`, `증가/감소 연산자(++/--)`, `delete 연산자`이다.

```javascript
var x;

// 할당 연산자는 변수 값이 변하는 부수 효과가 있다.
// 이는 x 변수를 사용하는 다른 코드에 영향을 준다.
x = 1;
console.log(x); // 1

// 증가/감소 연산자(++/--)는 피연산자의 값을 변경하는 부수 효과가 있다.
// 피연산자 x의 값이 재할당되어 변경된다. 이는 x 변수를 사용하는 다른 코드에 영향을 준다.
x++;
console.log(x); // 2

var o = { a: 1 };

// delete 연산자는 객체의 프로퍼티를 삭제하는 부수 효과가 있다.
// 이는 o 객체를 사용하는 다른 코드에 영향을 준다.
delete o.a;
console.log(o); // {}
```

# 7.12. 연산자 우선순위
- **🏷️연산자 우선순위: 여러 개의 연산자로 이뤄진 문이 실행될 때 연산자가 실행되는 순서**

| 우선순위 | 연산자 예시                                                                 |  
| ---- | ---------------------------------------------------------------------- |
| 1    | `()`                                                                   |
| 2    | `new` (매개변수 존재), `.`, `[]` (프로퍼티 접근), `()` (함수 호출), `?.` (옵셔널 체이닝 연산자) |
| 3    | `new` (매개변수 미존재)                                                       |
| 4    | `x++`, `x--`                                                           |
| 5    | `++x`, `--x`, `!x`, `+x`, `-x`, `typeof`, `delete`                     |
| 6    | `**`                                                                   |
| 7    | `*`, `/`, `%`                                                          |
| 8    | `+`, `-`                                                               |
| 9    | `<`, `<=`, `>`, `>=`, `in`, `instanceof`                               |
| 10   | `==`, `!=`, `===`, `!==`                                               |
| 11   | `??` (null 병합 연산자)                                                     |
| 12   | `&&`                                                                   |
| 13   | \`                                                                     |
| 14   | `? ... : ...` (삼항 연산자)                                                 |
| 15   | 할당 연산자 (`=`, `+=`, `-=`, ...)                                          |
| 16   | `,` (쉼표 연산자)                                                           |

- 모두 기억하기 어렵고 실수하기도 쉬우므로, 우선순위가 가장 높은 연산자를 사용해 우선순위를 명시적으로 조절하는 것이 좋다.

# 7.13. 연산자 결합 순서
- **🏷️연산자 결합 순서: 연산자의 어느쪽부터 평가를 수행할 것인지 나타내는 순서**

| 결합 순서       | 연산자 목록                 | 
| ----------- | ------------------------------------------------------------------------------------------------------------------ |
| **좌항 → 우항** | `+`, `-`, `/`, `%`, `<`, `<=`, `>`, `>=`, `&&`, `||`, `.`, `[]`, `()`, `??`, `?.`, `in`, `instanceof` |
| **우항 → 좌항** | `++`, `--`, `할당 연산자(=, +=, -=, ...)`, `!x`, `+x`, `-x`, `++x`, `--x`, `typeof`, `delete`, `? ... : ...` (삼항), `**` |